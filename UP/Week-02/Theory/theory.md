# Условен оператор **if**

**Условният оператор** проверява **дали дадено условие е изпълнено и спрямо този резултат изпълнява зададено следствие**. Той има две основни конструкции(форми): **кратка и пълна.**

## Кратка форма на if

Синтаксис:

```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява блокът от операции, ако върнатият резултат е false блокът се пропуска, т.е. няма да се изпълни нищо.

```c++
#include <iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;

	if (age < ALLOW_AGE)
		std::cout << "Drink denied" << std::endl;

	return 0;
}
```

## Пълна форма на if

Синтаксис:

```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
else
{
	// ...
	// блок от операции, които ще бъдат изпълнени
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява първият блок от операции, ако върнатият резултат е false - вторият блок.

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;

	if (age < ALLOW_AGE)
	{
		std::cout << "Drink denied" << std::endl;
	}
	else
	{
		std::cout << "Drink permitted" << std::endl;
	}

	return 0;
}
```

### **!!!NB**

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;

	if (age < ALLOW_AGE)
	{
		std::cout << "Drink denied" << std::endl;
	}
	return 0;
}
```

### Вложена форма(Nested form)

```c++
#include<iostream>

int main()
{
	int number = 15;

	if (number % 3 == 0)
	{
		if (!(number % 5))
			std::cout << "Divided by 3 and 5" << std::endl;
		else
			std::cout << "Divided by 3 but not by 5" << std::endl;
	}

	return 0;
}
```

### Други форми - if-else-if

Синтаксис и семантика:

```c++
if ( <булев_израз> )
{
	// ...
  	// Ако <булев_израз> е оценен с true, ще се изпълни този блок с операции
  	// ...
}
else if ( <друг_булев_израз> )
{
  	// ...
  	// Ако <друг_булев_израз> е оценен с true И <булев_израз> е оценен с false,
  	// тогава ще се изпълни този блок с операции
  	// ...
}
else // тази клауза не е задължителна
{
  	// ...
  	// ще се изпълни този блок, ако <булев_израз> И <друг_булев_израз> са оценени с false
  	// ...
}
```

```c++
#include<iostream>

int main()
{
	int a = 19;
	if (a % 2 == 0)
	{
	    std::cout << "divided by 2" << std::endl;
	}
	else if (a % 3 == 0)
	{
		std::cout << "divided by 3" << std::endl;
	}
	else
	{
	      std::cout << "Not divided by 2 and 3" << std::endl;
	}

	return 0;
}
```

# Тернарен оператор ?: (Ternary operator)

?: е форма която наподобява конструкцията if - else. Формално ще наричаме оператора ?: **тернарен оператор**.

Синтаксис:

```c++
<булев_израз> ? <оператор_при_истина> : <оператор_при_лъжа>
```

Семантика:
Изчислява се булевият израз, след което се изпълнява при:

- върнат резултат истина (true) - изпълнява се операторът след ?
- върнат резултат лъжа (false) - изпълнява се операторът след :

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 19;

	std::cout << (age < ALLOW_AGE ? "Drink denied" : "Drink permitted") << std::endl;

	return 0;
}
```

# Оператор switch(Switch statement)

Операторът **switch** позволява тестването на дадена променлива за равенство измежду списък от стойностти. Всяка стойност за проверка се нарича **случай (case).**

Синтаксис:

```c++
switch(<израз|стойност>)
{
	case <стойност_за_проверка>: <операции_за_изпълнение>; break; // break; не е задължително
	...
	case <стойност_за_проверка>: <операции_за_изпълнение>; break;

	default: <операции_за_изпълнение>; break;
}
```

Семантика: Подаваме дадена стойност като параметът на switch, след което се проверява в кой случай стойността от този параметър ще съвпадне по стойност с някоя стойност за проверка, при което се изпълнява операциите подадени към този случай. Ако никоя стойност не съвпадне с подадената се изпълнява случаят default.

### Допълнителни правила:

- може да имате **неограничен брой случаи (case)**, като трябва за всеки един да дадете стойност по която да се проверява;
- стойносттите, по които проверяваме, трябва да бъдат **от същия тип** както подадената за проверка;
- при откриване на съвпадение **се изпълняват подадените операции до срещане на оператор break**, т.е ако е влезнал във втория case и няма break в него, ще се изпълнят всички оператори в останалите case-ове до достигане на оператор break;
- при стигане до break, изпълнението на оператора switch се **прекратява и продължава изпълнението на програмата** след него;
- default е **опционален**, т.е не е от задължителния синтаксис на оператора switch. Той се използва когато никой от изброените условия не се е изпълнило и искаме да отбележим това;

```c++
#include <iostream>

int main () {
   // local variable declaration:
   char grade = 'D';

   switch(grade) {
      case 'A' :
         std::cout << "Excellent!" << std::endl;
         break;
      case 'B' :
      case 'C' :
         std::cout << "Well done" << std::endl;
         break;
      case 'D' :
         std::cout << "You passed" << std::endl;
         break;
      case 'F' :
         std::cout << "Better try again" << std::endl;
         break;
      default :
         std::cout << "Invalid grade" << std::endl;
   }
   std::cout << "Your grade is: " << grade << std::endl;

   return 0;
}
```

# Принципите DRY, KISS и SRP за писане на качествен код

Когато пишем код, е изключително важно да се придържаме към три принципа, които ни помагат той да бъде по-качествен:

- DRY = Don't Repeat Yourself! - Не трябва да пишете едно и също нещо няклоко пъти. Ако има начин да съкратите кода, да обедините случаи, да преизползвате кода си, направете го
- KISS = Keep It Simple, Stupid! - Недейте да правите кода ненужно сложен. Най-важното е той да бъде четим и разбираем за останалите. Чрез добро наименование и избягване на твърде шифрирани методи за решение на задача вие ще постигнете това.
- SRP = Single Responsibility Principle - Един блок, функция, структурна единица трябва да се грижи само за едно нещо. Например вие знаете, че, за да повдигнете на степен, ви е нужна функцията pow. Нейното предназначение е само това и нищо друго. Когато вие създавате нови функции в последствие, е важно да следите, дали не правите повече от едно нещо в нея.

# Математическо основание за съществуване и единственост на условната конструкция

Условният оператор може да се разгледа от няколко математически гледни точки. Една от тях е тази на математическата логика. Най-простота конструкция на if ни дава да разпишем следната формула - p -> q (p, q - твърдения, а в езика на УП p е булев израз, а q е набор от операции, които да се изпълнят). От вероятностна гледна точка едно събитие може да бъде разбито (има се предвид разпаднато) на няколко подслучая, които служат като хипотези. Заедно те са непресичащи се множества (тоест без общ елемент) и обединението им дава цялото вероятностно пространство. С по-прости думи чрез помощта на if, else if, else ние разписваме всички случаи и обозначаваме какво трябва да се случи при всеки от тях. В сферата на семантиката функцията се нарича if a then b1 else b2. Математически никога не може да имаме условна конструкция без else (както всъщност е застопорено и в езика Haskell), но в C++ е направено известно улеснение. Ако използваме кратката форма на if, то автоматично може да се предположи, че имаме else {}. В термините на алгебрата пък разбиването на случаи прави разглеждането на хипотезите като директна сума на всички случаи. \

### Пример 1

Да се напише програма, която при мятане на зар изписва дали се е паднала четна или нечетна стойност.

```cpp
#include <iostream>
int main() {
	int diceNumber = 1;
	std::cin >> diceNumber;
	if(diceNumber == 1) {
		std::cout << "Dice is odd" << std::endl;
	}
	else if(diceNumber == 2) {
		std::cout << "Dice is even" << std::endl;
	}
	else if(diceNumber == 3) {
		std::cout << "Dice is odd" << std::endl;
	}
	else if(diceNumber == 4) {
		std::cout << "Dice is even" << std::endl;
	}
	else if(diceNumber == 5) {
		std::cout << "Dice is odd" << std::endl;
	}
	else if(diceNumber == 6) {
		std::cout << "Dice is even" << std::endl;
	}
	return 0;
}
```

Тук разбихме на най-простите възможни случаи за мятане на зар. Стойностите на зара са крайни и вероятностите да се паднат са дискретни. Очевидно това генерира твърде много код и нарушава принципа DRY. Да го оптимизираме в:

### Пример 2

Виждаме, че различимите случаи са само 2 - четно и нечетно. Поради тази причина можем да обединим хипотезите за 1, 3 и 5 от една страна и 2, 4, 6 от друга страна. Ще учите по Дискретни, че обединение на множества е еквивалентна операция с логическото ИЛИ:

```cpp
#include <iostream>
int main() {
	int diceNumber = 1;
	std::cin >> diceNumber;
	if(diceNumber == 1 || diceNumber == 3 || diceNumber == 5) {
		std::cout << "Dice is odd" << std::endl;
	}
	else if(diceNumber == 2 || diceNumber == 4 || diceNumber == 6) {
		std::cout << "Dice is even" << std::endl;
	}
	return 0;
}
```

Тук вече не нарушаваме горния принцип. Все пак има още подобрения, които можем да направим:

### Пример 3

Забелязваме в миналия пример, че съществува такова изображение, което удовлетворява нашите условия - сравнение по модул 2. Има много математически доказателства за намиране на това изображение - например чрез първа стъпка на решетото на Ератостен:

```cpp
#include <iostream>
int main() {
	int diceNumber = 1;
	std::cin >> diceNumber;
	if(diceNumber % 2 == 1) {
		std::cout << "Dice is odd" << std::endl;
	}
	else if(diceNumber % 2 == 0) {
		std::cout << "Dice is even" << std::endl;
	}
	return 0;
}
```

Тук стигаме до обобщение на един много важен принцип от логиката - принципът за изключеното трето. Едно твърдение или е, или не е. Или е вярно, или е невярно. Чрез него можем да доведем всяко множество до разбиване на A и A-черта (неговото допълнение). Тук не е нужно да правим точно това заключение - просто може да разгледаме единия случай, а другият да не разбиваме въобще (той така или иначе не може да се разбие повече).

### Пример 4

```cpp
#include <iostream>
int main() {
	int diceNumber = 1;
	std::cin >> diceNumber;
	if(diceNumber % 2 == 1) {
		std::cout << "Dice is odd" << std::endl;
	}
	else {
		std::cout << "Dice is even" << std::endl;
	}
	return 0;
}
```

Така стигнахме до най-доброто разбиване на случаи. Кодовете от примери 1 до 3 са НЕДОСТАТЪЧНИ за пълен брой точки на контролно или домашно, защото са неоптимизирани откъм експресивност.

## Съществуване на условната конструкция

Доказателството ще направим съвсем интуитивно. Можем ли да имаме пълнота на действията без да имаме взимане на решения спрямо хипотези? Отговорът би бил не, защото прекъсвайки свойството на импликацията, вие ще прекъснете свойството да доказваме твърдения. Ще използваме метода на противоречието. Нека да предположим, че условната конструкция не съществува. Следователно всяка програма ще е напълно линейна и ще представлява само частен случай на реален обект (тоест от всички избори, които трябва да се правят, сме избрали специфични такива). Тогава можем да напишем още програми, които описват всички случаи (в дискретния, крайния случай) или ще са приближение до всички случаи (в аналоговия, реалния случай). Съответно ще бъде пускана програмата, която отговаря на специфичния случай, тоест ще се разглеждат условията и ще създадем нещо като условен оператор, което е в противоречие с допуснатото предположение. Следователно условна конструкция съществува.

## Единственост на условната конструкция

Нека да предположим, че съществуват две различни условни конструкции, които работят по различни начини. Ще докажем, че те са еквивалентни. Прост пример е ако имаме, че if изпълнява условието, когато булевият израз е true, а if' - когато изразът е false, то чрез просто полагане можем да покажем, че двете описват едни и същи обекти. Наистина всеки булев израз може да се представи чрез набор от други операции и каквито и изисквания да има if', той може да бъде приведен до if чрез полагане (доказателството следва от това, че всяка булева операция може да се представи, чрез набор от няколко базови такива - ИЛИ и НЕ, И и НЕ, Черта на Шефер, Стрелка на Пиърс и др.). Оттук следва, че двата if-a са еквивалентни и колкото и условни оператори да имаме, те се свеждат до един и същ реално. Кой от тях ще ползваме, зависи от задачата.
